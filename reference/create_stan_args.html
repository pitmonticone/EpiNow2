<!-- Generated by pkgdown: do not edit by hand -->
<!DOCTYPE html>
<html lang="en">
  <head>
  <meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<title>Create a List of Stan Arguments — create_stan_args • EpiNow2</title>


<!-- jquery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.4.1/jquery.min.js" integrity="sha256-CSXorXvZcTkaix6Yvo6HppcZGetbYMGWSFlBw8HfCJo=" crossorigin="anonymous"></script>
<!-- Bootstrap -->
<link href="https://cdnjs.cloudflare.com/ajax/libs/bootswatch/3.4.0/lumen/bootstrap.min.css" rel="stylesheet" crossorigin="anonymous" />


<script src="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.4.1/js/bootstrap.min.js" integrity="sha256-nuL8/2cJ5NDSSwnKD8VqreErSWHtnEP9E7AySL+1ev4=" crossorigin="anonymous"></script>

<!-- bootstrap-toc -->
<link rel="stylesheet" href="../bootstrap-toc.css">
<script src="../bootstrap-toc.js"></script>

<!-- Font Awesome icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/all.min.css" integrity="sha256-mmgLkCYLUQbXn0B1SRqzHar6dCnv9oZFPEC1g1cwlkk=" crossorigin="anonymous" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.12.1/css/v4-shims.min.css" integrity="sha256-wZjR52fzng1pJHwx4aV2AO3yyTOXrcDW7jBpJtTwVxw=" crossorigin="anonymous" />

<!-- clipboard.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.6/clipboard.min.js" integrity="sha256-inc5kl9MA1hkeYUt+EC3BhlIgyp/2jDIyBLS6k3UxPI=" crossorigin="anonymous"></script>

<!-- headroom.js -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/headroom.min.js" integrity="sha256-AsUX4SJE1+yuDu5+mAVzJbuYNPHj/WroHuZ8Ir/CkE0=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/headroom/0.11.0/jQuery.headroom.min.js" integrity="sha256-ZX/yNShbjqsohH1k95liqY9Gd8uOiE1S4vZc+9KQ1K4=" crossorigin="anonymous"></script>

<!-- pkgdown -->
<link href="../pkgdown.css" rel="stylesheet">
<script src="../pkgdown.js"></script>




<meta property="og:title" content="Create a List of Stan Arguments — create_stan_args" />
<meta property="og:description" content="Generates a list of arguments as required by rstan::sampling (when method = &quot;exact) or
rstan::vb (when method = &quot;approximate). See create_stan_args() for the defaults and the relevant rstan
functions for additonal options." />




<!-- mathjax -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/MathJax.js" integrity="sha256-nvJJv9wWKEm88qvoQl9ekL2J+k/RWIsaSScxxlsrv8k=" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/config/TeX-AMS-MML_HTMLorMML.js" integrity="sha256-84DKXVJXs0/F8OTMzX4UR909+jtl4G7SPypPavF+GfA=" crossorigin="anonymous"></script>

<!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->



  </head>

  <body data-spy="scroll" data-target="#toc">
    <div class="container template-reference-topic">
      <header>
      <div class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <span class="navbar-brand">
        <a class="navbar-link" href="../index.html">EpiNow2</a>
        <span class="version label label-default" data-toggle="tooltip" data-placement="bottom" title="Released version">1.2.0</span>
      </span>
    </div>

    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
<li>
  <a href="../reference/index.html">
    <span class="fa fa-file-code-o"></span>
     
    Functions
  </a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        <li>
  <a href="https://github.com/epiforecasts/EpiNow2">
    <span class="fa fa-github"></span>
     
  </a>
</li>
      </ul>
      
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

      

      </header>

<div class="row">
  <div class="col-md-9 contents">
    <div class="page-header">
    <h1>Create a List of Stan Arguments</h1>
    
    <div class="hidden name"><code>create_stan_args.Rd</code></div>
    </div>

    <div class="ref-description">
    <p>Generates a list of arguments as required by <code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-sampling.html'>rstan::sampling</a></code> (when <code>method = "exact</code>) or
<code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-vb.html'>rstan::vb</a></code> (when <code>method = "approximate</code>). See <code>create_stan_args()</code> for the defaults and the relevant <code>rstan</code>
functions for additonal options.</p>
    </div>

    <pre class="usage"><span class='fu'>create_stan_args</span><span class='op'>(</span>
  <span class='va'>model</span>,
  data <span class='op'>=</span> <span class='cn'>NULL</span>,
  init <span class='op'>=</span> <span class='st'>"random"</span>,
  samples <span class='op'>=</span> <span class='fl'>1000</span>,
  stan_args <span class='op'>=</span> <span class='cn'>NULL</span>,
  method <span class='op'>=</span> <span class='st'>"exact"</span>,
  verbose <span class='op'>=</span> <span class='cn'>FALSE</span>
<span class='op'>)</span></pre>

    <h2 class="hasAnchor" id="arguments"><a class="anchor" href="#arguments"></a>Arguments</h2>
    <table class="ref-arguments">
    <colgroup><col class="name" /><col class="desc" /></colgroup>
    <tr>
      <th>model</th>
      <td><p>A stan model object, defaults to packaged model if not supplied.</p></td>
    </tr>
    <tr>
      <th>data</th>
      <td><p>A list of stan data as created by <code>create_stan_data</code></p></td>
    </tr>
    <tr>
      <th>init</th>
      <td><p>Initial conditions passed to <code>rstan</code>. Defaults to "random" but can also be a function (
as supplied by <code>create_intitial_conditions</code>).</p></td>
    </tr>
    <tr>
      <th>samples</th>
      <td><p>Numeric, defaults to 1000. The overall number of posterior samples to return (Note: not the
number of samples per chain as is the default in stan).</p></td>
    </tr>
    <tr>
      <th>stan_args</th>
      <td><p>A list of stan arguments to be passed to <code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-sampling.html'>rstan::sampling</a></code> or <code><a href='https://mc-stan.org/rstan/reference/stanmodel-method-vb.html'>rstan::vb</a></code> (when using the "exact"
or "approximate" method). For <code>method = approximate</code> an additional argument <code>trials</code> indicates the number of attempts to make
using variational inference before returning an error (as stochastic failure is possible). The default for this is 5.</p></td>
    </tr>
    <tr>
      <th>method</th>
      <td><p>A character string defaults to "exact". Also accepts "approximate". Indicates the fitting method to be used
this can either be "exact" (NUTs sampling) or "approximate" (variational inference). The exact approach returns samples
from the posterior whilst the approximate method returns approximate samples. The approximate method is likely to return results
several order of magnitudes faster than the exact method.</p></td>
    </tr>
    <tr>
      <th>verbose</th>
      <td><p>Logical, defaults to <code>FALSE</code>. Should verbose progress messages be returned.</p></td>
    </tr>
    </table>

    <h2 class="hasAnchor" id="value"><a class="anchor" href="#value"></a>Value</h2>

    <p>A list of stan arguments</p>

    <h2 class="hasAnchor" id="examples"><a class="anchor" href="#examples"></a>Examples</h2>
    <pre class="examples"><div class='input'>
<span class='co'># default settings</span>
<span class='fu'>create_stan_args</span><span class='op'>(</span><span class='op'>)</span>
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector pdf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pdf = num_elements(pdf);
#&gt;     vector[t] convolved_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         convolved_cases[s] += dot_product(cases[max(1, (s - max_pdf + 1)):s], tail(pdf, min(max_pdf, s)));
#&gt;     }
#&gt;    return(convolved_cases);
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;   // discretised truncated lognormal pmf
#&gt;   real discretised_lognormal_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     real small = 1e-5;
#&gt;     real adj_y = y + small;
#&gt;     return((normal_cdf((log(adj_y + 1) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(adj_y) - mu) / sigma, 0.0, 1.0)) /
#&gt;            (normal_cdf((log(max_val + small) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(small) - mu) / sigma, 0.0, 1.0)));
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;  // discretised truncated gamma pmf
#&gt;   real discretised_gamma_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     // calculate alpha and beta for gamma distribution
#&gt;     real c_sigma = sigma + 1e-5;
#&gt;     real alpha = ((mu)/ c_sigma)^2;
#&gt;     real beta = (mu) / (c_sigma^2);
#&gt;     //account for numerical issues
#&gt;     alpha = alpha &lt; 0 ? 1e-5 : alpha;
#&gt;     beta = beta &lt; 0 ? 1e-5 : beta; 
#&gt;     alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;     beta = is_inf(beta) ? 1e8 : beta; 
#&gt;     return((gamma_cdf(y + 1, alpha, beta) - gamma_cdf(y, alpha, beta)) / 
#&gt;     (gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta)));
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;   // exponential quadratic kernal
#&gt; 	real spd_SE(real alpha, real rho, real w) {
#&gt; 		real S;
#&gt; 		S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt; 		return S;
#&gt; 	}
#&gt; 	
#&gt; 	// basis function for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	vector phi_SE(real L, int m, vector x) {
#&gt; 		vector[rows(x)] fi;
#&gt; 		fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt; 		return fi;
#&gt; 	}
#&gt; 	
#&gt; 	// eigenvalues for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	real lambda(real L, int m) {
#&gt; 		real lam;
#&gt; 		lam = ((m*pi())/(2*L))^2;
#&gt; 		return lam;
#&gt; 	}
#&gt; 	
#&gt; 	
#&gt; 	
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt;   int t;                             // number of time steps
#&gt;   int rt;                            // time over which to estimate rt
#&gt;   int horizon;                       // forecast horizon
#&gt;   int day_of_week[rt];               // day of the week indicator (1 - 7)
#&gt;   int&lt;lower = 0&gt; cases[rt - horizon];// observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;// median shifted smoothed cases
#&gt;   int delays;                        // no. of delay distributions
#&gt;   real delay_mean_sd[delays == 0 ? 1 : delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays == 0 ? 1 : delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays == 0 ? 1 : delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays == 0 ? 1 : delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays == 0 ? 1 : delays];       // maximum incubation period
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real L;				                     // boundary value for infections gp
#&gt; 	int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt; 	real lengthscale_mean;             // mean for gp lengthscale prior
#&gt; 	real lengthscale_sd;               // sd for gp lengthscale prior
#&gt; 	int est_week_eff;
#&gt; 	vector[rt] time;
#&gt; 	vector[t] inf_time;
#&gt; 	int stationary;                    // is underlying Rt assumed to be stationary (+ GP)
#&gt; 	int break_no;                      // no of breakpoints (0 = no breakpoints)
#&gt; 	int breakpoints[rt];               // when do breakpoints occur 
#&gt; 	int fixed;                        // Indicates if Rt/backcalculation is fixed 
#&gt; 	int future_fixed;                 // is underlying future Rt assumed to be fixed
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   real r_alpha;                              // alpha parameter of the R gamma prior
#&gt;   real r_beta;                               // beta parameter of the R gamma prior
#&gt;   int no_rt_time;                            // time without estimating Rt
#&gt;   int rt_h;                                  // rt estimation time minus the forecasting horizon
#&gt;   int noise_terms = estimate_r &gt; 0 ? (stationary &gt; 0 ? rt : rt - 1) : t;
#&gt;                                              // no. of noise terms
#&gt;   matrix[future_fixed &gt; 0 ? (noise_terms - horizon) : noise_terms, M] PHI;  // basis function 
#&gt;   
#&gt;   //Update number of noise terms based on furure Rt assumption
#&gt;   noise_terms = future_fixed &gt; 0 ? (noise_terms - horizon) : noise_terms;
#&gt;   
#&gt;   //Update time varables
#&gt;   rt_h = rt - horizon;
#&gt;   
#&gt;   // calculate alpha and beta for gamma distribution
#&gt;   r_alpha = (r_mean / r_sd)^2;
#&gt;   r_beta = r_mean / (r_sd^2);
#&gt;    
#&gt;    // time without estimating Rt is the differrence of t and rt
#&gt;    no_rt_time = t - rt;
#&gt;    
#&gt;    // basis functions
#&gt;    // see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt;    for (m in 1:M){ 
#&gt;      PHI[,m] = phi_SE(L, m, (estimate_r &gt; 0 ? time[1:noise_terms] : inf_time)); 
#&gt;     }
#&gt; }
#&gt; parameters{
#&gt;   simplex[est_week_eff ? 7 : 1] day_of_week_eff_raw;  // day of week reporting effect + control parameters
#&gt;   real&lt;lower = 0&gt; delay_mean[delays];                 // mean of delays
#&gt;   real&lt;lower = 0&gt; delay_sd[delays];                   // sd of delays
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];                // overdispersion of the reporting process
#&gt;   real&lt;lower = 0&gt; rho[fixed ? 0 : 1];                 // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];               // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;                          // unconstrained noise
#&gt;   vector[estimate_r] initial_R;                       // baseline reproduction number estimate
#&gt;   vector[estimate_r &gt; 0 ? no_rt_time : 0] initial_infections;
#&gt;                                                       // seed infections adjustment when estimating Rt
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];                // mean of generation time
#&gt;   real &lt;lower = 0&gt; gt_sd[estimate_r];                 // sd of generation time
#&gt;   real rt_break_eff[break_no];                        // Rt breakpoint effects
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   // stored transformed parameters
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise on the mean shifted observed cases
#&gt;   vector[t] infections;                                   // infections over time
#&gt;   vector[rt] reports;                                     // reports over time
#&gt;   vector[est_week_eff ? 7 : 0] day_of_week_eff;           // day of the week effect
#&gt;   vector[estimate_r &gt; 0 ? rt : 0] R;                      // reproduction number over time
#&gt;  {
#&gt;   // temporary transformed parameters                                 
#&gt;   vector[estimate_r &gt; 0 ? max_gt : 0] rev_generation_time;// reversed generation time pdf
#&gt;   vector[estimate_r &gt; 0 ? rt : 0] infectiousness;         // infections over time
#&gt;   vector[fixed &gt; 0 ? 0 : M] diagSPD;                      // spectral density
#&gt; 	vector[fixed &gt; 0 ? 0 : M] SPD_eta;                      // spectral density * noise
#&gt; 	int rt_break_count;                                     // counter for Rt breakpoints
#&gt; 	
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     for(m in 1:M){ 
#&gt; 		diagSPD[m] =  sqrt(spd_SE(alpha[1], rho[1], sqrt(lambda(L, m)))); 
#&gt; 		}
#&gt;   	SPD_eta = diagSPD .* eta;
#&gt; 	
#&gt;   	noise = rep_vector(1e-5, noise_terms);
#&gt;     noise = noise + exp(PHI[,] * SPD_eta);
#&gt;   }
#&gt;   
#&gt;   // initialise infections
#&gt;   infections = rep_vector(1e-5, t);
#&gt; 
#&gt;   // Estimate Rt and use this estimate to generate infections
#&gt;   if (estimate_r) {
#&gt;     // calculate pdf of generation time from distribution
#&gt;     for (j in 1:(max_gt)) {
#&gt;        rev_generation_time[j] =
#&gt;            discretised_gamma_pmf(max_gt - j + 1, gt_mean[estimate_r], 
#&gt;                                  gt_sd[estimate_r], max_gt);
#&gt;      }
#&gt;   // initialise breakpoints as 0
#&gt;   rt_break_count = 0;
#&gt;   // assume a global Rt * GP
#&gt;   if (stationary) {
#&gt;     R = rep_vector(initial_R[estimate_r], rt);
#&gt;     for (s in 1:rt) {
#&gt;       if (!fixed) {
#&gt;          if (!future_fixed || (s &lt;= noise_terms)) {
#&gt;            R[s] *= noise[s];
#&gt;          }else{
#&gt;            R[s] = R[s - 1];
#&gt;          }
#&gt;        
#&gt;       }
#&gt;       // apply breakpoints if present
#&gt;       if (break_no &gt; 0) {
#&gt;        rt_break_count += breakpoints[s];
#&gt;         if (rt_break_count &gt; 0) {
#&gt;           R[s] = R[s] * prod(rt_break_eff[1:rt_break_count]);
#&gt;         }
#&gt;       }
#&gt;     }
#&gt;   // assume GP on gradient of Rt (i.e Rt = R(t-1) * GP)
#&gt;   }else{
#&gt;     R[1] = initial_R[estimate_r];
#&gt;     for (s in 2:rt) {
#&gt;       if (!future_fixed || (s &lt;= (noise_terms + 1))) {
#&gt;         R[s] = R[s - 1] .* noise[s - 1];
#&gt;       }else{
#&gt;         R[s] = R[s - 1];
#&gt;       }
#&gt; 
#&gt;       // apply breakpoints if present
#&gt;       if (break_no &gt; 0) {
#&gt;         if (breakpoints[s] == 1) {
#&gt;           rt_break_count = sum(breakpoints[1:s]);
#&gt;           R[s] = R[s] * rt_break_eff[rt_break_count];
#&gt;         }
#&gt;       }
#&gt;     }
#&gt;   }
#&gt; 
#&gt;      // estimate initial infections not using Rt
#&gt;      infections[1:no_rt_time] = infections[1:no_rt_time] + 
#&gt;                                   shifted_cases[1:no_rt_time] .* exp(initial_infections);
#&gt;       
#&gt;      // estimate remaining infections using Rt
#&gt;      infectiousness = rep_vector(1e-5, rt);
#&gt;      for (s in 1:rt) {
#&gt;         infectiousness[s] += dot_product(infections[max(1, (s + no_rt_time - max_gt)):(s + no_rt_time -1)],
#&gt;                                          tail(rev_generation_time, min(max_gt, s + no_rt_time - 1)));
#&gt;         infections[s + no_rt_time] += R[s] * infectiousness[s];
#&gt;       }
#&gt;   }else{
#&gt;     // generate infections from prior infections and non-parameteric noise
#&gt;     if(!fixed) {
#&gt;       infections = infections + shifted_cases .* noise;
#&gt;     }else{
#&gt;       infections = infections + shifted_cases;
#&gt;     }
#&gt; 
#&gt;   }
#&gt; 
#&gt;   // reports from onsets
#&gt;   if (delays) {
#&gt;      {
#&gt;    vector[t] reports_hold;
#&gt;    for (s in 1:delays) {
#&gt;     // reverse the distributions to allow vectorised access
#&gt;     vector[max_delay[s]] rev_delay = rep_vector(1e-5, max_delay[s]);
#&gt;     for (j in 1:(max_delay[s])) {
#&gt;       rev_delay[j] +=
#&gt;         discretised_lognormal_pmf(max_delay[s] - j, delay_mean[s], delay_sd[s], max_delay[s]);
#&gt;     }
#&gt;      if (s == 1) {
#&gt;        reports_hold = convolve(infections, rev_delay);
#&gt;      }else{
#&gt;        reports_hold = convolve(reports_hold, rev_delay);
#&gt;      }
#&gt;    }
#&gt;     reports = reports_hold[(no_rt_time + 1):t];
#&gt;     }
#&gt;   }else{
#&gt;     reports = infections[(no_rt_time + 1):t];
#&gt;   }
#&gt; 
#&gt;  // Add optional weekly reporting effect
#&gt;  if (est_week_eff) {
#&gt;   // define day of the week effect
#&gt;   day_of_week_eff = 7 * day_of_week_eff_raw;
#&gt; 
#&gt;   for (s in 1:rt) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     reports[s] *= day_of_week_eff[day_of_week[s]];
#&gt;    }
#&gt;   }
#&gt;  }
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;   rho ~  normal(lengthscale_mean, lengthscale_sd);
#&gt;   alpha ~ normal(0, 0.1);
#&gt;   eta ~ std_normal();
#&gt;   }
#&gt; 
#&gt;   // reporting overdispersion
#&gt;   if (model_type) {
#&gt;     rep_phi[model_type] ~ exponential(1);
#&gt;   }
#&gt; 
#&gt;   // penalised priors for delaysincubation period, and report delay
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * t;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * t;
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   // estimate rt
#&gt;   if (estimate_r) {
#&gt;     // prior on R
#&gt;     initial_R[estimate_r] ~ gamma(r_alpha, r_beta);
#&gt;     initial_infections ~ normal(0, 0.1);
#&gt;     
#&gt;     // penalised_prior on generation interval
#&gt;     target += normal_lpdf(gt_mean | gt_mean_mean, gt_mean_sd) * rt;
#&gt;     target += normal_lpdf(gt_sd | gt_sd_mean, gt_sd_sd) * rt;
#&gt;     
#&gt;     //breakpoint effects on Rt
#&gt;     if (break_no &gt; 0) {
#&gt;       rt_break_eff ~ lognormal(0, 0.1);
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   // daily cases given reports
#&gt;   if (model_type) {
#&gt;     target += neg_binomial_2_lpmf(cases | reports[1:rt_h], rep_phi[model_type]);
#&gt;   }else{
#&gt;     target += poisson_lpmf(cases | reports[1:rt_h]);
#&gt;   }
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[rt]; 
#&gt;   real r[estimate_r &gt; 0 ? rt : 0];
#&gt;   
#&gt;   // estimate the growth rate
#&gt;   if (estimate_r) {
#&gt;       real k = pow(gt_sd[estimate_r] / gt_mean[estimate_r], 2);
#&gt;       for (s in 1:rt) {
#&gt;         r[s] = (pow(R[s], k) - 1) / (k * gt_mean[estimate_r]);
#&gt;       } 
#&gt;   }
#&gt;   
#&gt;   //simulate reported cases
#&gt;   if (model_type) {
#&gt;     for (s in 1:rt) {
#&gt;       imputed_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e7 ? 1e7 : reports[s], rep_phi[model_type]);
#&gt;     }
#&gt;    }else{
#&gt;     for (s in 1:rt) {
#&gt;       imputed_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt; }
#&gt;  
#&gt; 
#&gt; $data
#&gt; NULL
#&gt; 
#&gt; $init
#&gt; [1] "random"
#&gt; 
#&gt; $refresh
#&gt; [1] 0
#&gt; 
#&gt; $cores
#&gt; [1] 1
#&gt; 
#&gt; $warmup
#&gt; [1] 500
#&gt; 
#&gt; $chains
#&gt; [1] 4
#&gt; 
#&gt; $control
#&gt; $control$adapt_delta
#&gt; [1] 0.99
#&gt; 
#&gt; $control$max_treedepth
#&gt; [1] 15
#&gt; 
#&gt; 
#&gt; $save_warmup
#&gt; [1] FALSE
#&gt; 
#&gt; $iter
#&gt; [1] 750
#&gt; </div><div class='input'>
<span class='co'># approximate settings</span>
<span class='fu'>create_stan_args</span><span class='op'>(</span>method <span class='op'>=</span> <span class='st'>"approximate"</span><span class='op'>)</span> 
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector pdf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pdf = num_elements(pdf);
#&gt;     vector[t] convolved_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         convolved_cases[s] += dot_product(cases[max(1, (s - max_pdf + 1)):s], tail(pdf, min(max_pdf, s)));
#&gt;     }
#&gt;    return(convolved_cases);
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;   // discretised truncated lognormal pmf
#&gt;   real discretised_lognormal_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     real small = 1e-5;
#&gt;     real adj_y = y + small;
#&gt;     return((normal_cdf((log(adj_y + 1) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(adj_y) - mu) / sigma, 0.0, 1.0)) /
#&gt;            (normal_cdf((log(max_val + small) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(small) - mu) / sigma, 0.0, 1.0)));
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;  // discretised truncated gamma pmf
#&gt;   real discretised_gamma_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     // calculate alpha and beta for gamma distribution
#&gt;     real c_sigma = sigma + 1e-5;
#&gt;     real alpha = ((mu)/ c_sigma)^2;
#&gt;     real beta = (mu) / (c_sigma^2);
#&gt;     //account for numerical issues
#&gt;     alpha = alpha &lt; 0 ? 1e-5 : alpha;
#&gt;     beta = beta &lt; 0 ? 1e-5 : beta; 
#&gt;     alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;     beta = is_inf(beta) ? 1e8 : beta; 
#&gt;     return((gamma_cdf(y + 1, alpha, beta) - gamma_cdf(y, alpha, beta)) / 
#&gt;     (gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta)));
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;   // exponential quadratic kernal
#&gt; 	real spd_SE(real alpha, real rho, real w) {
#&gt; 		real S;
#&gt; 		S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt; 		return S;
#&gt; 	}
#&gt; 	
#&gt; 	// basis function for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	vector phi_SE(real L, int m, vector x) {
#&gt; 		vector[rows(x)] fi;
#&gt; 		fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt; 		return fi;
#&gt; 	}
#&gt; 	
#&gt; 	// eigenvalues for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	real lambda(real L, int m) {
#&gt; 		real lam;
#&gt; 		lam = ((m*pi())/(2*L))^2;
#&gt; 		return lam;
#&gt; 	}
#&gt; 	
#&gt; 	
#&gt; 	
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt;   int t;                             // number of time steps
#&gt;   int rt;                            // time over which to estimate rt
#&gt;   int horizon;                       // forecast horizon
#&gt;   int day_of_week[rt];               // day of the week indicator (1 - 7)
#&gt;   int&lt;lower = 0&gt; cases[rt - horizon];// observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;// median shifted smoothed cases
#&gt;   int delays;                        // no. of delay distributions
#&gt;   real delay_mean_sd[delays == 0 ? 1 : delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays == 0 ? 1 : delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays == 0 ? 1 : delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays == 0 ? 1 : delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays == 0 ? 1 : delays];       // maximum incubation period
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real L;				                     // boundary value for infections gp
#&gt; 	int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt; 	real lengthscale_mean;             // mean for gp lengthscale prior
#&gt; 	real lengthscale_sd;               // sd for gp lengthscale prior
#&gt; 	int est_week_eff;
#&gt; 	vector[rt] time;
#&gt; 	vector[t] inf_time;
#&gt; 	int stationary;                    // is underlying Rt assumed to be stationary (+ GP)
#&gt; 	int break_no;                      // no of breakpoints (0 = no breakpoints)
#&gt; 	int breakpoints[rt];               // when do breakpoints occur 
#&gt; 	int fixed;                        // Indicates if Rt/backcalculation is fixed 
#&gt; 	int future_fixed;                 // is underlying future Rt assumed to be fixed
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   real r_alpha;                              // alpha parameter of the R gamma prior
#&gt;   real r_beta;                               // beta parameter of the R gamma prior
#&gt;   int no_rt_time;                            // time without estimating Rt
#&gt;   int rt_h;                                  // rt estimation time minus the forecasting horizon
#&gt;   int noise_terms = estimate_r &gt; 0 ? (stationary &gt; 0 ? rt : rt - 1) : t;
#&gt;                                              // no. of noise terms
#&gt;   matrix[future_fixed &gt; 0 ? (noise_terms - horizon) : noise_terms, M] PHI;  // basis function 
#&gt;   
#&gt;   //Update number of noise terms based on furure Rt assumption
#&gt;   noise_terms = future_fixed &gt; 0 ? (noise_terms - horizon) : noise_terms;
#&gt;   
#&gt;   //Update time varables
#&gt;   rt_h = rt - horizon;
#&gt;   
#&gt;   // calculate alpha and beta for gamma distribution
#&gt;   r_alpha = (r_mean / r_sd)^2;
#&gt;   r_beta = r_mean / (r_sd^2);
#&gt;    
#&gt;    // time without estimating Rt is the differrence of t and rt
#&gt;    no_rt_time = t - rt;
#&gt;    
#&gt;    // basis functions
#&gt;    // see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt;    for (m in 1:M){ 
#&gt;      PHI[,m] = phi_SE(L, m, (estimate_r &gt; 0 ? time[1:noise_terms] : inf_time)); 
#&gt;     }
#&gt; }
#&gt; parameters{
#&gt;   simplex[est_week_eff ? 7 : 1] day_of_week_eff_raw;  // day of week reporting effect + control parameters
#&gt;   real&lt;lower = 0&gt; delay_mean[delays];                 // mean of delays
#&gt;   real&lt;lower = 0&gt; delay_sd[delays];                   // sd of delays
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];                // overdispersion of the reporting process
#&gt;   real&lt;lower = 0&gt; rho[fixed ? 0 : 1];                 // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];               // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;                          // unconstrained noise
#&gt;   vector[estimate_r] initial_R;                       // baseline reproduction number estimate
#&gt;   vector[estimate_r &gt; 0 ? no_rt_time : 0] initial_infections;
#&gt;                                                       // seed infections adjustment when estimating Rt
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];                // mean of generation time
#&gt;   real &lt;lower = 0&gt; gt_sd[estimate_r];                 // sd of generation time
#&gt;   real rt_break_eff[break_no];                        // Rt breakpoint effects
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   // stored transformed parameters
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise on the mean shifted observed cases
#&gt;   vector[t] infections;                                   // infections over time
#&gt;   vector[rt] reports;                                     // reports over time
#&gt;   vector[est_week_eff ? 7 : 0] day_of_week_eff;           // day of the week effect
#&gt;   vector[estimate_r &gt; 0 ? rt : 0] R;                      // reproduction number over time
#&gt;  {
#&gt;   // temporary transformed parameters                                 
#&gt;   vector[estimate_r &gt; 0 ? max_gt : 0] rev_generation_time;// reversed generation time pdf
#&gt;   vector[estimate_r &gt; 0 ? rt : 0] infectiousness;         // infections over time
#&gt;   vector[fixed &gt; 0 ? 0 : M] diagSPD;                      // spectral density
#&gt; 	vector[fixed &gt; 0 ? 0 : M] SPD_eta;                      // spectral density * noise
#&gt; 	int rt_break_count;                                     // counter for Rt breakpoints
#&gt; 	
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     for(m in 1:M){ 
#&gt; 		diagSPD[m] =  sqrt(spd_SE(alpha[1], rho[1], sqrt(lambda(L, m)))); 
#&gt; 		}
#&gt;   	SPD_eta = diagSPD .* eta;
#&gt; 	
#&gt;   	noise = rep_vector(1e-5, noise_terms);
#&gt;     noise = noise + exp(PHI[,] * SPD_eta);
#&gt;   }
#&gt;   
#&gt;   // initialise infections
#&gt;   infections = rep_vector(1e-5, t);
#&gt; 
#&gt;   // Estimate Rt and use this estimate to generate infections
#&gt;   if (estimate_r) {
#&gt;     // calculate pdf of generation time from distribution
#&gt;     for (j in 1:(max_gt)) {
#&gt;        rev_generation_time[j] =
#&gt;            discretised_gamma_pmf(max_gt - j + 1, gt_mean[estimate_r], 
#&gt;                                  gt_sd[estimate_r], max_gt);
#&gt;      }
#&gt;   // initialise breakpoints as 0
#&gt;   rt_break_count = 0;
#&gt;   // assume a global Rt * GP
#&gt;   if (stationary) {
#&gt;     R = rep_vector(initial_R[estimate_r], rt);
#&gt;     for (s in 1:rt) {
#&gt;       if (!fixed) {
#&gt;          if (!future_fixed || (s &lt;= noise_terms)) {
#&gt;            R[s] *= noise[s];
#&gt;          }else{
#&gt;            R[s] = R[s - 1];
#&gt;          }
#&gt;        
#&gt;       }
#&gt;       // apply breakpoints if present
#&gt;       if (break_no &gt; 0) {
#&gt;        rt_break_count += breakpoints[s];
#&gt;         if (rt_break_count &gt; 0) {
#&gt;           R[s] = R[s] * prod(rt_break_eff[1:rt_break_count]);
#&gt;         }
#&gt;       }
#&gt;     }
#&gt;   // assume GP on gradient of Rt (i.e Rt = R(t-1) * GP)
#&gt;   }else{
#&gt;     R[1] = initial_R[estimate_r];
#&gt;     for (s in 2:rt) {
#&gt;       if (!future_fixed || (s &lt;= (noise_terms + 1))) {
#&gt;         R[s] = R[s - 1] .* noise[s - 1];
#&gt;       }else{
#&gt;         R[s] = R[s - 1];
#&gt;       }
#&gt; 
#&gt;       // apply breakpoints if present
#&gt;       if (break_no &gt; 0) {
#&gt;         if (breakpoints[s] == 1) {
#&gt;           rt_break_count = sum(breakpoints[1:s]);
#&gt;           R[s] = R[s] * rt_break_eff[rt_break_count];
#&gt;         }
#&gt;       }
#&gt;     }
#&gt;   }
#&gt; 
#&gt;      // estimate initial infections not using Rt
#&gt;      infections[1:no_rt_time] = infections[1:no_rt_time] + 
#&gt;                                   shifted_cases[1:no_rt_time] .* exp(initial_infections);
#&gt;       
#&gt;      // estimate remaining infections using Rt
#&gt;      infectiousness = rep_vector(1e-5, rt);
#&gt;      for (s in 1:rt) {
#&gt;         infectiousness[s] += dot_product(infections[max(1, (s + no_rt_time - max_gt)):(s + no_rt_time -1)],
#&gt;                                          tail(rev_generation_time, min(max_gt, s + no_rt_time - 1)));
#&gt;         infections[s + no_rt_time] += R[s] * infectiousness[s];
#&gt;       }
#&gt;   }else{
#&gt;     // generate infections from prior infections and non-parameteric noise
#&gt;     if(!fixed) {
#&gt;       infections = infections + shifted_cases .* noise;
#&gt;     }else{
#&gt;       infections = infections + shifted_cases;
#&gt;     }
#&gt; 
#&gt;   }
#&gt; 
#&gt;   // reports from onsets
#&gt;   if (delays) {
#&gt;      {
#&gt;    vector[t] reports_hold;
#&gt;    for (s in 1:delays) {
#&gt;     // reverse the distributions to allow vectorised access
#&gt;     vector[max_delay[s]] rev_delay = rep_vector(1e-5, max_delay[s]);
#&gt;     for (j in 1:(max_delay[s])) {
#&gt;       rev_delay[j] +=
#&gt;         discretised_lognormal_pmf(max_delay[s] - j, delay_mean[s], delay_sd[s], max_delay[s]);
#&gt;     }
#&gt;      if (s == 1) {
#&gt;        reports_hold = convolve(infections, rev_delay);
#&gt;      }else{
#&gt;        reports_hold = convolve(reports_hold, rev_delay);
#&gt;      }
#&gt;    }
#&gt;     reports = reports_hold[(no_rt_time + 1):t];
#&gt;     }
#&gt;   }else{
#&gt;     reports = infections[(no_rt_time + 1):t];
#&gt;   }
#&gt; 
#&gt;  // Add optional weekly reporting effect
#&gt;  if (est_week_eff) {
#&gt;   // define day of the week effect
#&gt;   day_of_week_eff = 7 * day_of_week_eff_raw;
#&gt; 
#&gt;   for (s in 1:rt) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     reports[s] *= day_of_week_eff[day_of_week[s]];
#&gt;    }
#&gt;   }
#&gt;  }
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;   rho ~  normal(lengthscale_mean, lengthscale_sd);
#&gt;   alpha ~ normal(0, 0.1);
#&gt;   eta ~ std_normal();
#&gt;   }
#&gt; 
#&gt;   // reporting overdispersion
#&gt;   if (model_type) {
#&gt;     rep_phi[model_type] ~ exponential(1);
#&gt;   }
#&gt; 
#&gt;   // penalised priors for delaysincubation period, and report delay
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * t;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * t;
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   // estimate rt
#&gt;   if (estimate_r) {
#&gt;     // prior on R
#&gt;     initial_R[estimate_r] ~ gamma(r_alpha, r_beta);
#&gt;     initial_infections ~ normal(0, 0.1);
#&gt;     
#&gt;     // penalised_prior on generation interval
#&gt;     target += normal_lpdf(gt_mean | gt_mean_mean, gt_mean_sd) * rt;
#&gt;     target += normal_lpdf(gt_sd | gt_sd_mean, gt_sd_sd) * rt;
#&gt;     
#&gt;     //breakpoint effects on Rt
#&gt;     if (break_no &gt; 0) {
#&gt;       rt_break_eff ~ lognormal(0, 0.1);
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   // daily cases given reports
#&gt;   if (model_type) {
#&gt;     target += neg_binomial_2_lpmf(cases | reports[1:rt_h], rep_phi[model_type]);
#&gt;   }else{
#&gt;     target += poisson_lpmf(cases | reports[1:rt_h]);
#&gt;   }
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[rt]; 
#&gt;   real r[estimate_r &gt; 0 ? rt : 0];
#&gt;   
#&gt;   // estimate the growth rate
#&gt;   if (estimate_r) {
#&gt;       real k = pow(gt_sd[estimate_r] / gt_mean[estimate_r], 2);
#&gt;       for (s in 1:rt) {
#&gt;         r[s] = (pow(R[s], k) - 1) / (k * gt_mean[estimate_r]);
#&gt;       } 
#&gt;   }
#&gt;   
#&gt;   //simulate reported cases
#&gt;   if (model_type) {
#&gt;     for (s in 1:rt) {
#&gt;       imputed_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e7 ? 1e7 : reports[s], rep_phi[model_type]);
#&gt;     }
#&gt;    }else{
#&gt;     for (s in 1:rt) {
#&gt;       imputed_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt; }
#&gt;  
#&gt; 
#&gt; $data
#&gt; NULL
#&gt; 
#&gt; $init
#&gt; [1] "random"
#&gt; 
#&gt; $refresh
#&gt; [1] 0
#&gt; 
#&gt; $trials
#&gt; [1] 10
#&gt; 
#&gt; $iter
#&gt; [1] 10000
#&gt; 
#&gt; $output_samples
#&gt; [1] 1000
#&gt; </div><div class='input'><span class='co'># increasing warmup</span>
<span class='fu'>create_stan_args</span><span class='op'>(</span>stan_args <span class='op'>=</span> <span class='fu'><a href='https://rdrr.io/r/base/list.html'>list</a></span><span class='op'>(</span>warmup <span class='op'>=</span> <span class='fl'>1000</span><span class='op'>)</span><span class='op'>)</span>
</div><div class='output co'>#&gt; $object
#&gt; S4 class stanmodel 'estimate_infections' coded as follows:
#&gt; functions {
#&gt; 
#&gt; // convolve a pdf and case vector 
#&gt; vector convolve(vector cases, vector pdf) {
#&gt;     int t = num_elements(cases);
#&gt;     int max_pdf = num_elements(pdf);
#&gt;     vector[t] convolved_cases = rep_vector(1e-5, t);
#&gt;     for (s in 1:t) {
#&gt;         convolved_cases[s] += dot_product(cases[max(1, (s - max_pdf + 1)):s], tail(pdf, min(max_pdf, s)));
#&gt;     }
#&gt;    return(convolved_cases);
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;   // discretised truncated lognormal pmf
#&gt;   real discretised_lognormal_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     real small = 1e-5;
#&gt;     real adj_y = y + small;
#&gt;     return((normal_cdf((log(adj_y + 1) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(adj_y) - mu) / sigma, 0.0, 1.0)) /
#&gt;            (normal_cdf((log(max_val + small) - mu) / sigma, 0.0, 1.0) -
#&gt;             normal_cdf((log(small) - mu) / sigma, 0.0, 1.0)));
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;  // discretised truncated gamma pmf
#&gt;   real discretised_gamma_pmf(int y, real mu, real sigma, int max_val) {
#&gt;     // calculate alpha and beta for gamma distribution
#&gt;     real c_sigma = sigma + 1e-5;
#&gt;     real alpha = ((mu)/ c_sigma)^2;
#&gt;     real beta = (mu) / (c_sigma^2);
#&gt;     //account for numerical issues
#&gt;     alpha = alpha &lt; 0 ? 1e-5 : alpha;
#&gt;     beta = beta &lt; 0 ? 1e-5 : beta; 
#&gt;     alpha = is_inf(alpha) ? 1e8 : alpha;
#&gt;     beta = is_inf(beta) ? 1e8 : beta; 
#&gt;     return((gamma_cdf(y + 1, alpha, beta) - gamma_cdf(y, alpha, beta)) / 
#&gt;     (gamma_cdf(max_val + 1, alpha, beta) - gamma_cdf(1, alpha, beta)));
#&gt;   }
#&gt;   
#&gt;   
#&gt;   
#&gt; 
#&gt;   // exponential quadratic kernal
#&gt; 	real spd_SE(real alpha, real rho, real w) {
#&gt; 		real S;
#&gt; 		S = (alpha^2) * sqrt(2*pi()) * rho * exp(-0.5*(rho^2)*(w^2));
#&gt; 		return S;
#&gt; 	}
#&gt; 	
#&gt; 	// basis function for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	vector phi_SE(real L, int m, vector x) {
#&gt; 		vector[rows(x)] fi;
#&gt; 		fi = 1/sqrt(L) * sin(m*pi()/(2*L) * (x+L));
#&gt; 		return fi;
#&gt; 	}
#&gt; 	
#&gt; 	// eigenvalues for approximate hilbert space gp
#&gt; 	// see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt; 	real lambda(real L, int m) {
#&gt; 		real lam;
#&gt; 		lam = ((m*pi())/(2*L))^2;
#&gt; 		return lam;
#&gt; 	}
#&gt; 	
#&gt; 	
#&gt; 	
#&gt; }
#&gt; 
#&gt; 
#&gt; data {
#&gt;   int t;                             // number of time steps
#&gt;   int rt;                            // time over which to estimate rt
#&gt;   int horizon;                       // forecast horizon
#&gt;   int day_of_week[rt];               // day of the week indicator (1 - 7)
#&gt;   int&lt;lower = 0&gt; cases[rt - horizon];// observed cases
#&gt;   vector&lt;lower = 0&gt;[t] shifted_cases;// median shifted smoothed cases
#&gt;   int delays;                        // no. of delay distributions
#&gt;   real delay_mean_sd[delays == 0 ? 1 : delays];  // prior sd of mean incubation period
#&gt;   real delay_mean_mean[delays == 0 ? 1 : delays];// prior mean of mean incubation period
#&gt;   real delay_sd_mean[delays == 0 ? 1 : delays];  // prior sd of sd of incubation period
#&gt;   real delay_sd_sd[delays == 0 ? 1 : delays];    // prior sd of sd of incubation period
#&gt;   int max_delay[delays == 0 ? 1 : delays];       // maximum incubation period
#&gt;   real &lt;lower = 0&gt; r_mean;           // prior mean of reproduction number
#&gt;   real &lt;lower = 0&gt; r_sd;             // prior standard deviation of reproduction number
#&gt;   real gt_mean_sd;                   // prior sd of mean generation time
#&gt;   real gt_mean_mean;                 // prior mean of mean generation time
#&gt;   real gt_sd_mean;                   // prior sd of sd of generation time
#&gt;   real gt_sd_sd;                     // prior sd of sd of generation time
#&gt;   int max_gt;                        // maximum generation time
#&gt;   int model_type;                    // type of model: 0 = poisson otherwise negative binomial
#&gt;   int estimate_r;                    // should the reproduction no be estimated (1 = yes)
#&gt;   real L;				                     // boundary value for infections gp
#&gt; 	int&lt;lower=1&gt; M;			               // basis functions for infections gp
#&gt; 	real lengthscale_mean;             // mean for gp lengthscale prior
#&gt; 	real lengthscale_sd;               // sd for gp lengthscale prior
#&gt; 	int est_week_eff;
#&gt; 	vector[rt] time;
#&gt; 	vector[t] inf_time;
#&gt; 	int stationary;                    // is underlying Rt assumed to be stationary (+ GP)
#&gt; 	int break_no;                      // no of breakpoints (0 = no breakpoints)
#&gt; 	int breakpoints[rt];               // when do breakpoints occur 
#&gt; 	int fixed;                        // Indicates if Rt/backcalculation is fixed 
#&gt; 	int future_fixed;                 // is underlying future Rt assumed to be fixed
#&gt; }
#&gt; 
#&gt; transformed data{
#&gt;   real r_alpha;                              // alpha parameter of the R gamma prior
#&gt;   real r_beta;                               // beta parameter of the R gamma prior
#&gt;   int no_rt_time;                            // time without estimating Rt
#&gt;   int rt_h;                                  // rt estimation time minus the forecasting horizon
#&gt;   int noise_terms = estimate_r &gt; 0 ? (stationary &gt; 0 ? rt : rt - 1) : t;
#&gt;                                              // no. of noise terms
#&gt;   matrix[future_fixed &gt; 0 ? (noise_terms - horizon) : noise_terms, M] PHI;  // basis function 
#&gt;   
#&gt;   //Update number of noise terms based on furure Rt assumption
#&gt;   noise_terms = future_fixed &gt; 0 ? (noise_terms - horizon) : noise_terms;
#&gt;   
#&gt;   //Update time varables
#&gt;   rt_h = rt - horizon;
#&gt;   
#&gt;   // calculate alpha and beta for gamma distribution
#&gt;   r_alpha = (r_mean / r_sd)^2;
#&gt;   r_beta = r_mean / (r_sd^2);
#&gt;    
#&gt;    // time without estimating Rt is the differrence of t and rt
#&gt;    no_rt_time = t - rt;
#&gt;    
#&gt;    // basis functions
#&gt;    // see here for details: https://arxiv.org/pdf/2004.11408.pdf
#&gt;    for (m in 1:M){ 
#&gt;      PHI[,m] = phi_SE(L, m, (estimate_r &gt; 0 ? time[1:noise_terms] : inf_time)); 
#&gt;     }
#&gt; }
#&gt; parameters{
#&gt;   simplex[est_week_eff ? 7 : 1] day_of_week_eff_raw;  // day of week reporting effect + control parameters
#&gt;   real&lt;lower = 0&gt; delay_mean[delays];                 // mean of delays
#&gt;   real&lt;lower = 0&gt; delay_sd[delays];                   // sd of delays
#&gt;   real&lt;lower = 0&gt; rep_phi[model_type];                // overdispersion of the reporting process
#&gt;   real&lt;lower = 0&gt; rho[fixed ? 0 : 1];                 // length scale of noise GP
#&gt;   real&lt;lower = 0&gt; alpha[fixed ? 0 : 1];               // scale of of noise GP
#&gt;   vector[fixed ? 0 : M] eta;                          // unconstrained noise
#&gt;   vector[estimate_r] initial_R;                       // baseline reproduction number estimate
#&gt;   vector[estimate_r &gt; 0 ? no_rt_time : 0] initial_infections;
#&gt;                                                       // seed infections adjustment when estimating Rt
#&gt;   real&lt;lower = 0&gt; gt_mean[estimate_r];                // mean of generation time
#&gt;   real &lt;lower = 0&gt; gt_sd[estimate_r];                 // sd of generation time
#&gt;   real rt_break_eff[break_no];                        // Rt breakpoint effects
#&gt; }
#&gt; 
#&gt; transformed parameters {
#&gt;   // stored transformed parameters
#&gt;   vector[fixed ? 0 : noise_terms] noise;                  // noise on the mean shifted observed cases
#&gt;   vector[t] infections;                                   // infections over time
#&gt;   vector[rt] reports;                                     // reports over time
#&gt;   vector[est_week_eff ? 7 : 0] day_of_week_eff;           // day of the week effect
#&gt;   vector[estimate_r &gt; 0 ? rt : 0] R;                      // reproduction number over time
#&gt;  {
#&gt;   // temporary transformed parameters                                 
#&gt;   vector[estimate_r &gt; 0 ? max_gt : 0] rev_generation_time;// reversed generation time pdf
#&gt;   vector[estimate_r &gt; 0 ? rt : 0] infectiousness;         // infections over time
#&gt;   vector[fixed &gt; 0 ? 0 : M] diagSPD;                      // spectral density
#&gt; 	vector[fixed &gt; 0 ? 0 : M] SPD_eta;                      // spectral density * noise
#&gt; 	int rt_break_count;                                     // counter for Rt breakpoints
#&gt; 	
#&gt;   // GP in noise - spectral densities
#&gt;   if (!fixed) {
#&gt;     for(m in 1:M){ 
#&gt; 		diagSPD[m] =  sqrt(spd_SE(alpha[1], rho[1], sqrt(lambda(L, m)))); 
#&gt; 		}
#&gt;   	SPD_eta = diagSPD .* eta;
#&gt; 	
#&gt;   	noise = rep_vector(1e-5, noise_terms);
#&gt;     noise = noise + exp(PHI[,] * SPD_eta);
#&gt;   }
#&gt;   
#&gt;   // initialise infections
#&gt;   infections = rep_vector(1e-5, t);
#&gt; 
#&gt;   // Estimate Rt and use this estimate to generate infections
#&gt;   if (estimate_r) {
#&gt;     // calculate pdf of generation time from distribution
#&gt;     for (j in 1:(max_gt)) {
#&gt;        rev_generation_time[j] =
#&gt;            discretised_gamma_pmf(max_gt - j + 1, gt_mean[estimate_r], 
#&gt;                                  gt_sd[estimate_r], max_gt);
#&gt;      }
#&gt;   // initialise breakpoints as 0
#&gt;   rt_break_count = 0;
#&gt;   // assume a global Rt * GP
#&gt;   if (stationary) {
#&gt;     R = rep_vector(initial_R[estimate_r], rt);
#&gt;     for (s in 1:rt) {
#&gt;       if (!fixed) {
#&gt;          if (!future_fixed || (s &lt;= noise_terms)) {
#&gt;            R[s] *= noise[s];
#&gt;          }else{
#&gt;            R[s] = R[s - 1];
#&gt;          }
#&gt;        
#&gt;       }
#&gt;       // apply breakpoints if present
#&gt;       if (break_no &gt; 0) {
#&gt;        rt_break_count += breakpoints[s];
#&gt;         if (rt_break_count &gt; 0) {
#&gt;           R[s] = R[s] * prod(rt_break_eff[1:rt_break_count]);
#&gt;         }
#&gt;       }
#&gt;     }
#&gt;   // assume GP on gradient of Rt (i.e Rt = R(t-1) * GP)
#&gt;   }else{
#&gt;     R[1] = initial_R[estimate_r];
#&gt;     for (s in 2:rt) {
#&gt;       if (!future_fixed || (s &lt;= (noise_terms + 1))) {
#&gt;         R[s] = R[s - 1] .* noise[s - 1];
#&gt;       }else{
#&gt;         R[s] = R[s - 1];
#&gt;       }
#&gt; 
#&gt;       // apply breakpoints if present
#&gt;       if (break_no &gt; 0) {
#&gt;         if (breakpoints[s] == 1) {
#&gt;           rt_break_count = sum(breakpoints[1:s]);
#&gt;           R[s] = R[s] * rt_break_eff[rt_break_count];
#&gt;         }
#&gt;       }
#&gt;     }
#&gt;   }
#&gt; 
#&gt;      // estimate initial infections not using Rt
#&gt;      infections[1:no_rt_time] = infections[1:no_rt_time] + 
#&gt;                                   shifted_cases[1:no_rt_time] .* exp(initial_infections);
#&gt;       
#&gt;      // estimate remaining infections using Rt
#&gt;      infectiousness = rep_vector(1e-5, rt);
#&gt;      for (s in 1:rt) {
#&gt;         infectiousness[s] += dot_product(infections[max(1, (s + no_rt_time - max_gt)):(s + no_rt_time -1)],
#&gt;                                          tail(rev_generation_time, min(max_gt, s + no_rt_time - 1)));
#&gt;         infections[s + no_rt_time] += R[s] * infectiousness[s];
#&gt;       }
#&gt;   }else{
#&gt;     // generate infections from prior infections and non-parameteric noise
#&gt;     if(!fixed) {
#&gt;       infections = infections + shifted_cases .* noise;
#&gt;     }else{
#&gt;       infections = infections + shifted_cases;
#&gt;     }
#&gt; 
#&gt;   }
#&gt; 
#&gt;   // reports from onsets
#&gt;   if (delays) {
#&gt;      {
#&gt;    vector[t] reports_hold;
#&gt;    for (s in 1:delays) {
#&gt;     // reverse the distributions to allow vectorised access
#&gt;     vector[max_delay[s]] rev_delay = rep_vector(1e-5, max_delay[s]);
#&gt;     for (j in 1:(max_delay[s])) {
#&gt;       rev_delay[j] +=
#&gt;         discretised_lognormal_pmf(max_delay[s] - j, delay_mean[s], delay_sd[s], max_delay[s]);
#&gt;     }
#&gt;      if (s == 1) {
#&gt;        reports_hold = convolve(infections, rev_delay);
#&gt;      }else{
#&gt;        reports_hold = convolve(reports_hold, rev_delay);
#&gt;      }
#&gt;    }
#&gt;     reports = reports_hold[(no_rt_time + 1):t];
#&gt;     }
#&gt;   }else{
#&gt;     reports = infections[(no_rt_time + 1):t];
#&gt;   }
#&gt; 
#&gt;  // Add optional weekly reporting effect
#&gt;  if (est_week_eff) {
#&gt;   // define day of the week effect
#&gt;   day_of_week_eff = 7 * day_of_week_eff_raw;
#&gt; 
#&gt;   for (s in 1:rt) {
#&gt;     // add reporting effects (adjust for simplex scale)
#&gt;     reports[s] *= day_of_week_eff[day_of_week[s]];
#&gt;    }
#&gt;   }
#&gt;  }
#&gt; }
#&gt; 
#&gt; model {
#&gt;   // priors for noise GP
#&gt;   if (!fixed) {
#&gt;   rho ~  normal(lengthscale_mean, lengthscale_sd);
#&gt;   alpha ~ normal(0, 0.1);
#&gt;   eta ~ std_normal();
#&gt;   }
#&gt; 
#&gt;   // reporting overdispersion
#&gt;   if (model_type) {
#&gt;     rep_phi[model_type] ~ exponential(1);
#&gt;   }
#&gt; 
#&gt;   // penalised priors for delaysincubation period, and report delay
#&gt;   if (delays) {
#&gt;     for (s in 1:delays) {
#&gt;       target += normal_lpdf(delay_mean[s] | delay_mean_mean[s], delay_mean_sd[s]) * t;
#&gt;       target += normal_lpdf(delay_sd[s] | delay_sd_mean[s], delay_sd_sd[s]) * t;
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   // estimate rt
#&gt;   if (estimate_r) {
#&gt;     // prior on R
#&gt;     initial_R[estimate_r] ~ gamma(r_alpha, r_beta);
#&gt;     initial_infections ~ normal(0, 0.1);
#&gt;     
#&gt;     // penalised_prior on generation interval
#&gt;     target += normal_lpdf(gt_mean | gt_mean_mean, gt_mean_sd) * rt;
#&gt;     target += normal_lpdf(gt_sd | gt_sd_mean, gt_sd_sd) * rt;
#&gt;     
#&gt;     //breakpoint effects on Rt
#&gt;     if (break_no &gt; 0) {
#&gt;       rt_break_eff ~ lognormal(0, 0.1);
#&gt;     }
#&gt;   }
#&gt; 
#&gt;   // daily cases given reports
#&gt;   if (model_type) {
#&gt;     target += neg_binomial_2_lpmf(cases | reports[1:rt_h], rep_phi[model_type]);
#&gt;   }else{
#&gt;     target += poisson_lpmf(cases | reports[1:rt_h]);
#&gt;   }
#&gt; }
#&gt;   
#&gt; generated quantities {
#&gt;   int imputed_reports[rt]; 
#&gt;   real r[estimate_r &gt; 0 ? rt : 0];
#&gt;   
#&gt;   // estimate the growth rate
#&gt;   if (estimate_r) {
#&gt;       real k = pow(gt_sd[estimate_r] / gt_mean[estimate_r], 2);
#&gt;       for (s in 1:rt) {
#&gt;         r[s] = (pow(R[s], k) - 1) / (k * gt_mean[estimate_r]);
#&gt;       } 
#&gt;   }
#&gt;   
#&gt;   //simulate reported cases
#&gt;   if (model_type) {
#&gt;     for (s in 1:rt) {
#&gt;       imputed_reports[s] = neg_binomial_2_rng(reports[s] &gt; 1e7 ? 1e7 : reports[s], rep_phi[model_type]);
#&gt;     }
#&gt;    }else{
#&gt;     for (s in 1:rt) {
#&gt;       imputed_reports[s] = poisson_rng(reports[s] &gt; 1e8 ? 1e8 : reports[s]);
#&gt;     }
#&gt;   }
#&gt; }
#&gt;  
#&gt; 
#&gt; $data
#&gt; NULL
#&gt; 
#&gt; $init
#&gt; [1] "random"
#&gt; 
#&gt; $refresh
#&gt; [1] 0
#&gt; 
#&gt; $cores
#&gt; [1] 1
#&gt; 
#&gt; $chains
#&gt; [1] 4
#&gt; 
#&gt; $control
#&gt; $control$adapt_delta
#&gt; [1] 0.99
#&gt; 
#&gt; $control$max_treedepth
#&gt; [1] 15
#&gt; 
#&gt; 
#&gt; $save_warmup
#&gt; [1] FALSE
#&gt; 
#&gt; $warmup
#&gt; [1] 1000
#&gt; 
#&gt; $iter
#&gt; [1] 1250
#&gt; </div></pre>
  </div>
  <div class="col-md-3 hidden-xs hidden-sm" id="pkgdown-sidebar">
    <nav id="toc" data-toggle="toc" class="sticky-top">
      <h2 data-toc-skip>Contents</h2>
    </nav>
  </div>
</div>


      <footer>
      <div class="copyright">
  <p>Developed by Sam Abbott, Joel Hellewell, Robin Thompson, Katelyn Gostic, Katharine Sherratt, Sophie Meakin, James Munday, Nikos Bosse, Joe Hickson, EpiForecasts, Sebastian Funk.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="https://pkgdown.r-lib.org/">pkgdown</a> 1.6.1.9000.</p>
</div>

      </footer>
   </div>

  


  </body>
</html>


